import { CallStack } from '../CallStack/CallStack';
import { RuntimeChoice } from '../Choice/Choice';
import { RuntimeContainer } from '../Container';
import { RuntimeObject } from '../Object';
import { RuntimePath } from '../Path';
import { Pointer } from '../Pointer';
import { PushPopType } from '../PushPopType';
import { StatePatch } from './StatePatch';
import { RuntimeStory } from './Story';
import { StringValue } from '../Value/StringValue';
import { VariablesState } from '../Variable/VariablesState';
export declare class StoryState {
    readonly _story: RuntimeStory;
    readonly kInkSaveStateVersion = 8;
    readonly kMinCompatibleLoadVersion = 8;
    currentErrors: string[];
    currentWarnings: string[];
    variablesState: VariablesState;
    callStack: CallStack;
    evaluationStack: RuntimeObject[];
    divertedPointer: Pointer;
    currentTurnIndex: number;
    storySeed: number;
    previousRandom: number;
    didSafeExit: boolean;
    story: RuntimeStory;
    private _visitCounts;
    get visitCounts(): Map<string, number>;
    private _turnIndices;
    get turnIndices(): Map<string, number>;
    private _outputStream;
    get outputStream(): RuntimeObject[];
    private _outputStreamTextDirty;
    get outputStreamTextDirty(): boolean;
    private _outputStreamTagsDirty;
    get outputStreamTagsDirty(): boolean;
    private _currentChoices;
    get currentChoices(): RuntimeChoice[];
    private _patch;
    get patch(): StatePatch;
    get callstackDepth(): number;
    get currentPathString(): string;
    get currentPointer(): Pointer;
    set currentPointer(value: Pointer);
    get previousPointer(): Pointer;
    set previousPointer(value: Pointer);
    get canContinue(): boolean;
    get hasError(): boolean;
    get hasWarning(): boolean;
    private _currentText;
    get currentText(): string;
    private _currentTags;
    get currentTags(): string[];
    get inExpressionEvaluation(): boolean;
    set inExpressionEvaluation(value: boolean);
    get outputStreamEndsInNewline(): boolean;
    get outputStreamContainsContent(): boolean;
    get inStringEvaluation(): boolean;
    readonly ToJson: (spaces?: number | undefined) => string;
    readonly LoadJson: (json: string) => void;
    readonly VisitCountAtPathString: (pathString: string) => number;
    readonly VisitCountForContainer: (container: RuntimeContainer) => number;
    readonly IncrementVisitCountForContainer: (container: RuntimeContainer) => void;
    readonly RecordTurnIndexVisitToContainer: (container: RuntimeContainer) => void;
    readonly TurnsSinceForContainer: (container: RuntimeContainer) => number;
    readonly CleanOutputWhitespace: (str: string) => string;
    constructor(_story: RuntimeStory);
    readonly GoToStart: () => void;
    readonly CopyAndStartPatching: () => StoryState;
    readonly RestoreAfterPatch: () => void;
    readonly ApplyAnyPatch: () => void;
    readonly ApplyCountChanges: (container: RuntimeContainer, newCount: number, isVisit: boolean) => void;
    readonly GetSerializedRepresentation: () => Record<string, any>;
    readonly LoadJsonObj: (jObject: Record<string, any>) => void;
    readonly ResetErrors: () => void;
    readonly ResetOutput: (objs?: RuntimeObject[]) => void;
    readonly PushToOutputStream: (obj: RuntimeObject) => void;
    readonly PopFromOutputStream: (count: number) => void;
    readonly TrySplittingHeadTailWhitespace: (single: StringValue) => StringValue[];
    readonly PushToOutputStreamIndividual: (obj: RuntimeObject) => void;
    readonly TrimNewlinesFromOutputStream: () => void;
    readonly RemoveExistingGlue: () => void;
    readonly PushEvaluationStack: (obj: RuntimeObject) => void;
    readonly PopEvaluationStack: <T extends number | undefined = undefined>(numberOfObjects?: T | undefined) => T extends 1 | undefined ? RuntimeObject : RuntimeObject[];
    readonly PeekEvaluationStack: () => RuntimeObject;
    readonly ForceEnd: () => void;
    readonly TrimWhitespaceFromFunctionEnd: () => void;
    readonly PopCallstack: (popType?: PushPopType) => void;
    readonly SetChosenPath: (path: RuntimePath, incrementingTurnIndex: boolean) => void;
    readonly StartFunctionEvaluationFromGame: (funcContainer: RuntimeContainer, ...args: any[]) => void;
    readonly PassArgumentsToEvaluationStack: (...args: any[]) => void;
    readonly TryExitFunctionEvaluationFromGame: () => boolean;
    readonly CompleteFunctionEvaluationFromGame: () => any;
    readonly AddError: (message: string, isWarning: boolean) => void;
    readonly OutputStreamDirty: () => void;
}

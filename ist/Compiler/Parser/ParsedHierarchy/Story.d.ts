import { RuntimeContainer } from '../../../Runtime/Container';
import { ErrorHandler } from '../../../ErrorHandler';
import { Expression } from './Expression/Expression';
import { ExternalDeclaration } from './Declaration/ExternalDeclaration';
import { FlowBase } from './Flow/FlowBase';
import { FlowLevel } from './Flow/FlowLevel';
import { ListDefinition } from './List/ListDefinition';
import { ListElementDefinition } from './List/ListElementDefinition';
import { Object } from './Object';
import { RuntimeStory } from '../../../Runtime/Story/Story';
import { SymbolType } from './SymbolType';
export declare class Story extends FlowBase {
    static readonly IsReservedKeyword: (name: string) => boolean;
    private _errorHandler;
    private _hadError;
    private _hadWarning;
    private _dontFlattenContainers;
    private _listDefs;
    get flowLevel(): FlowLevel;
    get hadError(): boolean;
    get hadWarning(): boolean;
    constants: Record<string, Expression>;
    externals: Record<string, ExternalDeclaration>;
    countAllVisits: boolean;
    constructor(toplevelObjects: Object[], isInclude?: boolean);
    readonly PreProcessTopLevelObjects: (topLevelContent: Object[]) => void;
    readonly ExportRuntime: (errorHandler?: ErrorHandler) => RuntimeStory;
    readonly ResolveList: (listName: string) => ListDefinition;
    readonly ResolveListItem: (listName: string, itemName: string, source?: Object) => ListElementDefinition;
    readonly FlattenContainersIn: (container: RuntimeContainer) => void;
    readonly TryFlattenContainer: (container: RuntimeContainer) => void;
    readonly Error: (message: string, source: Object, isWarning: boolean) => void;
    readonly ResetError: () => void;
    readonly IsExternal: (namedFuncTarget: string) => boolean;
    readonly AddExternal: (decl: ExternalDeclaration) => void;
    readonly DontFlattenContainer: (container: RuntimeContainer) => void;
    readonly NameConflictError: (obj: Object, name: string, existingObj: Object, typeNameToPrint: string) => void;
    readonly CheckForNamingCollisions: (obj: Object, name: string, symbolType: SymbolType, typeNameOverride?: string) => void;
}

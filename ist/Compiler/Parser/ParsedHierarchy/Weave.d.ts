import { RuntimeContainer } from '../../../Runtime/Container';
import { Gather } from './Gather/Gather';
import { GatherPointToResolve } from './Gather/GatherPointToResolve';
import { IWeavePoint } from './IWeavePoint';
import { Object } from './Object';
import { RuntimeObject } from '../../../Runtime/Object';
import { Story } from './Story';
declare type BadTerminationHandler = (terminatingObj: Object) => void;
export declare class Weave extends Object {
    get rootContainer(): RuntimeContainer;
    previousWeavePoint: IWeavePoint;
    addContentToPreviousWeavePoint: boolean;
    hasSeenChoiceInSection: boolean;
    currentContainer: RuntimeContainer;
    baseIndentIndex: number;
    private _unnamedGatherCount;
    private _choiceCount;
    private _rootContainer;
    private _namedWeavePoints;
    looseEnds: IWeavePoint[];
    gatherPointsToResolve: GatherPointToResolve[];
    get lastParsedSignificantObject(): Object;
    constructor(cont: Object[], indentIndex?: number);
    readonly ResolveWeavePointNaming: () => void;
    readonly ConstructWeaveHierarchyFromIndentation: () => void;
    readonly DetermineBaseIndentationFromContent: (contentList: Object[]) => number;
    readonly GenerateRuntimeObject: () => RuntimeObject;
    readonly AddRuntimeForGather: (gather: Gather) => void;
    readonly AddRuntimeForWeavePoint: (weavePoint: IWeavePoint) => void;
    readonly AddRuntimeForNestedWeave: (nestedResult: Weave) => void;
    readonly AddGeneralRuntimeContent: (content: RuntimeObject) => void;
    readonly PassLooseEndsToAncestors: () => void;
    readonly ReceiveLooseEnd: (childWeaveLooseEnd: IWeavePoint) => void;
    readonly ResolveReferences: (context: Story) => void;
    readonly WeavePointNamed: (name: string) => IWeavePoint;
    readonly IsGlobalDeclaration: (obj: Object) => boolean;
    readonly ContentThatFollowsWeavePoint: (weavePoint: IWeavePoint) => Object[];
    readonly ValidateTermination: (badTerminationHandler: BadTerminationHandler) => void;
    readonly BadNestedTerminationHandler: BadTerminationHandler;
    readonly ValidateFlowOfObjectsTerminates: (objFlow: Object[], defaultObj: Object, badTerminationHandler: BadTerminationHandler) => void;
    readonly WeavePointHasLooseEnd: (weavePoint: IWeavePoint) => boolean;
    readonly CheckForWeavePointNamingCollisions: () => void;
}
export {};

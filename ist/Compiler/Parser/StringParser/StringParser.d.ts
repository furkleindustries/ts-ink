import { CharacterSet } from '../CharacterSet';
import { ErrorHandler } from '../../../ErrorHandler';
import { Object } from '../ParsedHierarchy/Object';
import { StringParserState } from './StringParserState';
import { StringParserElement } from './StringParserElement';
export declare const ParseSuccess: unique symbol;
export declare type ParseRule = () => ParseRuleReturn;
export declare type ParseRuleReturn = object | string | number | typeof StringParser['ParseSuccess'];
export declare type SpecificParseRule<T extends ParseRule> = T;
export declare abstract class StringParser {
    ParseRule: ParseRule;
    static readonly ParseSuccess: typeof ParseSuccess;
    static readonly numbersCharacterSet: CharacterSet;
    private _chars;
    errorHandler: ErrorHandler;
    state: StringParserState;
    hadError: boolean;
    constructor(str: string);
    get currentCharacter(): string;
    readonly PreProcessInputString: (str: string) => string;
    readonly BeginRule: () => number;
    readonly FailRule: (expectedRuleId: number) => ParseRuleReturn;
    readonly CancelRule: (expectedRuleId: number) => void;
    readonly SucceedRule: (expectedRuleId: number, result?: ParseRuleReturn) => ParseRuleReturn;
    RuleDidSucceed: (result: ParseRuleReturn, startState: StringParserElement, endState: StringParserElement) => void;
    readonly Expect: (rule: ParseRule, message?: string, recoveryRule?: ParseRule) => ParseRuleReturn;
    Error: (message: string, isWarning?: boolean) => void;
    readonly ErrorWithParsedObject: (message: string, result: Object, isWarning?: boolean) => void;
    readonly ErrorOnLine: (message: string, lineNumber: number, isWarning: boolean) => void;
    readonly Warning: (message: string) => void;
    get endOfInput(): boolean;
    get remainingString(): string;
    readonly LineRemainder: () => string;
    get remainingLength(): number;
    inputString: string;
    get lineIndex(): number;
    set lineIndex(value: number);
    get index(): number;
    set index(value: number);
    readonly SetFlag: (flag: number, trueOrFalse: boolean) => void;
    readonly GetFlag: (flag: number) => boolean;
    ParseObject: (rule: ParseRule) => ParseRuleReturn;
    readonly Parse: <T extends ParseRule>(rule: T) => ParseRuleReturn;
    readonly OneOf: (array: ParseRule[]) => ParseRuleReturn;
    readonly OneOrMore: (rule: ParseRule) => ParseRuleReturn[];
    readonly Optional: (rule: ParseRule) => ParseRule;
    readonly Exclude: (rule: ParseRule) => ParseRule;
    readonly OptionalExclude: (rule: ParseRule) => ParseRule;
    readonly String: (str: string) => ParseRule;
    private readonly TryAddResultToList;
    readonly Interleave: <T>(ruleA: ParseRule, ruleB: ParseRule, untilTerminator?: ParseRule | null, flatten?: boolean) => T[];
    readonly ParseString: (str: string) => string;
    readonly ParseSingleCharacter: () => string;
    readonly ParseUntilCharactersFromString: (str: string, maxCount?: number) => string;
    readonly ParseUntilCharactersFromCharSet: (charSet: CharacterSet, maxCount?: number) => string;
    readonly ParseCharactersFromString: (str: string, maxCountOrShouldIncludeStrChars?: number | boolean, maxCount?: number) => string;
    readonly ParseCharactersFromCharSet: (charSet: CharacterSet, shouldIncludeChars?: boolean, maxCount?: number) => string;
    readonly Peek: (rule: ParseRule) => ParseRuleReturn;
    ParseUntil(stopRule: ParseRule, pauseCharacters?: CharacterSet, endCharacters?: CharacterSet): string;
    readonly ParseInt: () => number | null;
    readonly ParseFloat: () => number | null;
    readonly ParseNewline: () => string;
}
